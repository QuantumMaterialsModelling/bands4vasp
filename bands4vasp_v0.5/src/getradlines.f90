program getradlines
  use math
  implicit none
  integer :: n, i, nweight
  real(dp), parameter :: eps=0.00001_dp
  real(dp) :: r, r_start, r_end, dr, cx, cy, cz, sx, sy, sz, ex, ey, ez, w1, w2, w, t
  character(20) :: inchar
  character(60) :: filename, kcoords,endpoints
  logical :: ldr=.false.

  ! Vectors for circle in any plane
  real(dp) :: vs(3), ve(3), nvec(3), u(3), v(3), wvec(3), p(3)
  real(dp) :: norm_vs, norm_ve, norm_nvec, theta, alpha, dotp, orient, diff

  call get_command_argument(1,inchar)
  read(inchar,*) n
  call get_command_argument(2,kcoords)
  call get_command_argument(3,filename)
  call get_command_argument(4,inchar)
  read(inchar,*) nweight
  if(nweight==1)then
    call get_command_argument(5,inchar)
    read(inchar,*) w1
    call get_command_argument(6,inchar)
    read(inchar,*) w2
  end if

  open(unit=24,file=trim(kcoords),status='old',action='read')
    read(24,*) cx, cy, cz
    read(24,*) sx, sy, sz
    read(24,*) ex, ey, ez
  close(24)

  write(*,*) 'Get points from KPOINTS file'
  write(*,'(A,3f12.8)') 'center      ::', cx, cy, cz
  write(*,'(A,3f12.8)') 'start point ::', sx, sy, sz
  write(*,'(A,3f12.8)') 'end point   ::', ex, ey, ez
  write(*,*) ''

  ! Direction vectors from center point to start/end point
  vs = (/ sx-cx, sy-cy, sz-cz /)
  ve = (/ ex-cx, ey-cy, ez-cz /)

  ! Start and end radius (for testing)
  r_start = sqrt(DDOT_PRODUCT(vs,vs))
  r_end = sqrt(DDOT_PRODUCT(ve,ve))
  r = 0.5_dp * (r_start + r_end)

  if(abs(r_start-r_end) > eps) then
    write(*,'(A,2f12.8)') 'Warning: Start and end radius are different!', r_start, r_end
    write(*,'(A)') 'This can lead to a strongly varying density of electron states,'
    write(*,'(A)') 'which in turn makes it very difficult to automatically calculate a Fermi surface.'
  end if

  ! Normal of the plane (cross product)
  nvec = CROSS_PRODUCT(vs, ve)
  norm_nvec = sqrt(DDOT_PRODUCT(nvec, nvec))
  wvec = nvec / norm_nvec

  ! u: Direction to the starting point
  u = vs / r_start
  ! v: sperpendicular to u and wvec, lies in the circular plane
  v = CROSS_PRODUCT(wvec, u)

  ! Angle between start and end point vector (in the circular sense, i.e. along wvec)
  dotp = min(1.0_dp, max(-1.0_dp, DDOT_PRODUCT(vs, ve)/(r_start*r_end)))
  theta = acos(dotp)
  orient = DDOT_PRODUCT(nvec, wvec)
  if (orient < 0.0_dp) then
    theta = 2.0_dp*pi - theta
  end if

  open(unit=23,file=trim(filename),status='replace',action='write')

  ! All points are generated by parameterized sampling
  do i=0, n-1
    t = real(i, dp) / real(n-1, dp)         ! Uniform parameter interpolation: 0...1
    alpha = t * theta                       ! From start angle (0) to target angle (theta)
    p = (/ cx, cy, cz /) + r * (cos(alpha)*u + sin(alpha)*v)
    if(nweight==1)then
      if(abs(w1-w2)<=eps)then
        w=w1
      else
        w=w1 + ((w2-w1)*t)
      end if
      write(23,'(4f12.8)') p(1), p(2), p(3), w
    else
      write(23,'(3f12.8)') p(1), p(2), p(3)
    end if
  end do

  close(23)


end program getradlines